// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v2.1.0-1-g1f618f69-wicked-fork
// source: query.sql

package orders

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"time"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/rs/zerolog/log"
)

const createAuthor = `-- name: CreateAuthor :one
INSERT INTO Orders (
  UserID, ItemID, IsDeleted
) VALUES (
  $1, $2, FALSE
)
RETURNING id, userid, itemid, price, createdat, isdeleted
`

type CreateAuthorParams struct {
	Userid int32
	Itemid int32
}

func (q *Queries) CreateAuthor(ctx context.Context, arg CreateAuthorParams) (*Order, error) {
	row := q.db.WQueryRow(ctx, "orders.CreateAuthor", createAuthor, arg.Userid, arg.Itemid)
	var i *Order = new(Order)
	err := row.Scan(
		&i.ID,
		&i.Userid,
		&i.Itemid,
		&i.Price,
		&i.CreatedAt,
		&i.Isdeleted,
	)
	if err == pgx.ErrNoRows {
		return (*Order)(nil), nil
	} else if err != nil {
		return nil, err
	}

	return i, err
}

const deleteOrder = `-- name: DeleteOrder :exec
UPDATE Orders
SET
  IsDeleted = TRUE
WHERE
  id = $1
`

func (q *Queries) DeleteOrder(ctx context.Context, id int32) error {
	_, err := q.db.WExec(ctx, "orders.DeleteOrder", deleteOrder, id)
	if err != nil {
		return err
	}

	return nil
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT
  Orders.ID,
  Orders.UserID,
  Orders.ItemID,
  Orders.CreatedAt,
  Users.Name AS UserName,
  Users.Thumbnail AS UserThumbnail,
  Items.Name AS ItemName,
  Items.Description As ItemDesc,
  Items.Price As ItemPrice,
  Items.Thumbnail As ItemThumbnail,
  Items.Metadata As ItemMetadata
FROM
  Orders
  INNER JOIN Items ON Orders.ItemID = Items.ID
  INNER JOIN Users ON Orders.UserID = Users.ID
WHERE
  Orders.IsDeleted = FALSE
`

type GetOrderByIDRow struct {
	ID            int32
	Userid        int32
	Itemid        int32
	CreatedAt     time.Time
	Username      string
	Userthumbnail string
	Itemname      string
	Itemdesc      string
	Itemprice     pgtype.Numeric
	Itemthumbnail string
	Itemmetadata  []byte
}

// -- cache : 10m
func (q *Queries) GetOrderByID(ctx context.Context) (*GetOrderByIDRow, error) {
	dbRead := func() (any, time.Duration, error) {
		cacheDuration := time.Duration(time.Millisecond * 600000)
		row := q.db.WQueryRow(ctx, "orders.GetOrderByID", getOrderByID)
		var i *GetOrderByIDRow = new(GetOrderByIDRow)
		err := row.Scan(
			&i.ID,
			&i.Userid,
			&i.Itemid,
			&i.CreatedAt,
			&i.Username,
			&i.Userthumbnail,
			&i.Itemname,
			&i.Itemdesc,
			&i.Itemprice,
			&i.Itemthumbnail,
			&i.Itemmetadata,
		)
		if err == pgx.ErrNoRows {
			return (*GetOrderByIDRow)(nil), cacheDuration, nil
		}
		return i, cacheDuration, err
	}
	if q.cache == nil {
		i, _, err := dbRead()
		return i.(*GetOrderByIDRow), err
	}

	var i *GetOrderByIDRow
	err := q.cache.GetWithTtl(ctx, "orders:GetOrderByID:", &i, dbRead, false, false)
	if err != nil {
		return nil, err
	}

	return i, err
}

const listOrdersByGender = `-- name: ListOrdersByGender :many
WITH UsersByGender AS (
  SELECT id, name, metadata, thumbnail, createdat FROM Users WHERE Users.Metadata->>'gender' = $3::text
)
SELECT id, userid, itemid, price, createdat, isdeleted FROM Orders
WHERE
  UserId IN (SELECT id FROM UsersByGender) AND Orders.ID > $1
LIMIT $2
`

type ListOrdersByGenderParams struct {
	After  int32
	First  int32
	Gender string
}

// CacheKey - cache key
func (arg ListOrdersByGenderParams) CacheKey() string {
	prefix := "orders:ListOrdersByGender:"
	return prefix + hashIfLong(fmt.Sprintf("%+v,%+v,%+v", arg.After, arg.First, arg.Gender))
}

// -- cache : 1m
// This is just an example for using type annotation for JSON field and 'with clause'.
func (q *Queries) ListOrdersByGender(ctx context.Context, arg ListOrdersByGenderParams) ([]Order, error) {
	dbRead := func() (any, time.Duration, error) {
		cacheDuration := time.Duration(time.Millisecond * 60000)
		rows, err := q.db.WQuery(ctx, "orders.ListOrdersByGender", listOrdersByGender, arg.After, arg.First, arg.Gender)
		if err != nil {
			return nil, 0, err
		}
		defer rows.Close()
		var items []Order
		for rows.Next() {
			var i *Order = new(Order)
			if err := rows.Scan(
				&i.ID,
				&i.Userid,
				&i.Itemid,
				&i.Price,
				&i.CreatedAt,
				&i.Isdeleted,
			); err != nil {
				return nil, 0, err
			}
			items = append(items, *i)
		}
		if err := rows.Err(); err != nil {
			return nil, 0, err
		}
		return items, cacheDuration, nil
	}
	if q.cache == nil {
		items, _, err := dbRead()
		return items.([]Order), err
	}
	var items []Order
	err := q.cache.GetWithTtl(ctx, arg.CacheKey(), &items, dbRead, false, false)
	if err != nil {
		return nil, err
	}

	return items, err
}

const listOrdersByUser = `-- name: ListOrdersByUser :many
SELECT id, userid, itemid, price, createdat, isdeleted FROM Orders
WHERE
  UserID = $1 AND CreatedAt < $2
ORDER BY CreatedAt DESC
LIMIT $3
`

type ListOrdersByUserParams struct {
	Userid int32
	After  time.Time
	First  int32
}

func (q *Queries) ListOrdersByUser(ctx context.Context, arg ListOrdersByUserParams) ([]Order, error) {
	rows, err := q.db.WQuery(ctx, "orders.ListOrdersByUser", listOrdersByUser, arg.Userid, arg.After, arg.First)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var i *Order = new(Order)
		if err := rows.Scan(
			&i.ID,
			&i.Userid,
			&i.Itemid,
			&i.Price,
			&i.CreatedAt,
			&i.Isdeleted,
		); err != nil {
			return nil, err
		}
		items = append(items, *i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}

	return items, err
}

//// auto generated functions

func (q *Queries) Dump(ctx context.Context, beforeDump ...BeforeDump) ([]byte, error) {
	sql := "SELECT id,userid,itemid,price,createdat,isdeleted FROM orders ORDER BY id,userid,itemid,price,createdat,isdeleted ASC;"
	rows, err := q.db.WQuery(ctx, "orders.Dump", sql)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Order
	for rows.Next() {
		var v Order
		if err := rows.Scan(&v.ID, &v.Userid, &v.Itemid, &v.Price, &v.CreatedAt, &v.Isdeleted); err != nil {
			return nil, err
		}
		for _, applyBeforeDump := range beforeDump {
			applyBeforeDump(&v)
		}
		items = append(items, v)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	bytes, err := json.MarshalIndent(items, "", "  ")
	if err != nil {
		return nil, err
	}
	return bytes, nil
}

func (q *Queries) Load(ctx context.Context, data []byte) error {
	sql := "INSERT INTO orders (id,userid,itemid,price,createdat,isdeleted) VALUES ($1,$2,$3,$4,$5,$6);"
	rows := make([]Order, 0)
	err := json.Unmarshal(data, &rows)
	if err != nil {
		return err
	}
	for _, row := range rows {
		_, err := q.db.WExec(ctx, "orders.Load", sql, row.ID, row.Userid, row.Itemid, row.Price, row.CreatedAt, row.Isdeleted)
		if err != nil {
			return err
		}
	}
	return nil
}

func hashIfLong(v string) string {
	if len(v) > 64 {
		hash := sha256.Sum256([]byte(v))
		return "h(" + hex.EncodeToString(hash[:]) + ")"
	}
	return v
}

// eliminate unused error
var _ = log.Logger
var _ = fmt.Sprintf("")
var _ = time.Now()
var _ = json.RawMessage{}
var _ = sha256.Sum256(nil)
var _ = hex.EncodeToString(nil)
